/**
 * @author See Contributors.txt for code contributors and overview of BadgerDB.
 *
 * @section LICENSE
 * Copyright (c) 2012 Database Group, Computer Sciences Department, University of Wisconsin-Madison.
 */

#include "btree.h"
#include "filescan.h"
#include "exceptions/bad_index_info_exception.h"
#include "exceptions/bad_opcodes_exception.h"
#include "exceptions/bad_scanrange_exception.h"
#include "exceptions/no_such_key_found_exception.h"
#include "exceptions/scan_not_initialized_exception.h"
#include "exceptions/index_scan_completed_exception.h"
#include "exceptions/file_not_found_exception.h"
#include "exceptions/end_of_file_exception.h"

#include <string>
#include <sstream>
#include <vector>


//#define DEBUG

namespace badgerdb
{

// -----------------------------------------------------------------------------
// BTreeIndex::BTreeIndex -- Constructor
// -----------------------------------------------------------------------------
BTreeIndex::BTreeIndex(const std::string & relationName,
		std::string & outIndexName,
		BufMgr *bufMgrIn,
		const int attrByteOffset,
		const Datatype attrType)
{

    /*
    printf("BTreeIndex: constructor invoked\n");

    //Init buffer manager, attr type, attr offset
    this->bufMgr = bufMgrIn;
    this->attributeType = attrType;
    this->attrByteOffset = attrByteOffset;

    //Determine index filename
    std::ostringstream idxStr;
    idxStr<<relationName<<"."<<attrByteOffset;
    std::string indexName = idxStr.str();

    outIndexName = indexName;

    //Init non-leaf and leaf node occupancy
    if(attrType == INTEGER) {
        this->leafOccupancy = INTARRAYLEAFSIZE;
        this->nodeOccupancy = INTARRAYNONLEAFSIZE;

    } else if(attrType == DOUBLE) {
        this->leafOccupancy = DOUBLEARRAYLEAFSIZE;
        this->nodeOccupancy = DOUBLEARRAYNONLEAFSIZE;

    } else if(attrType == STRING) {
        this->leafOccupancy = STRINGARRAYLEAFSIZE;
        this->nodeOccupancy = STRINGARRAYNONLEAFSIZE;
    }

    printf("Node and leaf occupancy: %d, %d\n", this->nodeOccupancy, this->leafOccupancy);

    //Open or create the index file
    if(File::exists(indexName)) {
        printf("BTreeIndex: constructor: existing file read\n");
        this->file = new BlobFile(indexName, false);

        //Read info from meta info page
        const PageId metaInfoPageNo = 1;
        Page* metaInfoPage = NULL;
        this->bufMgr->readPage(this->file, metaInfoPageNo, metaInfoPage);
        struct IndexMetaInfo* indexMetaInfo = (struct IndexMetaInfo*)(metaInfoPage);
        this->rootPageNum = indexMetaInfo->rootPageNo;
        this->height = indexMetaInfo->height;

        //Release meta info page
        this->bufMgr->unPinPage(this->file, metaInfoPageNo, false);
    }
    else {
        printf("BTreeIndex: constructor: new index file created\n");
        this->file = new BlobFile(indexName, true);

        PageId metaInfoPageNo = 0;
        Page* metaInfoPage = NULL;

        //Allocate meta info page for the index page
        this->bufMgr->allocPage(this->file, metaInfoPageNo, metaInfoPage);
        assert(metaInfoPageNo == 1);

        this->headerPageNum = metaInfoPageNo;
        struct IndexMetaInfo* indexMetaInfo = (struct IndexMetaInfo*)metaInfoPage;
        strncpy(indexMetaInfo->relationName, indexName.c_str(), indexName.length());
        indexMetaInfo->attrByteOffset = attrByteOffset;
        indexMetaInfo->attrType = attrType;

        //Allocate root page for the index file
        PageId rootPageNo = 0;
        Page* rootPage = NULL;
        this->bufMgr->allocPage(this->file, rootPageNo, rootPage);
        this->rootPageNum = indexMetaInfo->rootPageNo = rootPageNo;
        this->height = indexMetaInfo->height = 0;

        //Build the root node as leaf to init the tree structure
        if(attrType == INTEGER) {
            //cast the root as a new leaf node
            struct LeafNodeInt* rootNode = (struct LeafNodeInt*)rootPage;

            //Init the new node
            for(int i = 0; i < this->leafOccupancy; i ++ ){
                rootNode->keyArray[i] = 0;
            }
            rootNode->rightSibPageNo = 0;
            rootNode->usage = 0;

        } else {
            printf("Btree constructor for double and string not implemented yet\n");
            return;
        }

        //Release meta info page
        this->bufMgr->unPinPage(this->file, metaInfoPageNo, true);
        //Release root node
        this->bufMgr->unPinPage(this->file, this->rootPageNum, true);
    }

//    printMeta();

    printf("BTreeIndex: constructor finished\n");
    */
}


// -----------------------------------------------------------------------------
// BTreeIndex::~BTreeIndex -- destructor
// -----------------------------------------------------------------------------

BTreeIndex::~BTreeIndex()
{ }


// -----------------------------------------------------------------------------
// Helper function. Insert an entry to a non-full leaf node. 
// Shift elements as needed, but no splitting will happen
// -----------------------------------------------------------------------------
const void BTreeIndex::insertEntryLeafNotFull(const void* key, const RecordId rid, void* node) {
    /*
    if(this->attributeType == INTEGER) {
        struct LeafNodeInt* curNode = (struct LeafNodeInt*)node;

        assert(curNode->usage < this->nodeOccupancy);

        int keyVal = *(int*)key;
        int i = 0;
        for(i = 0; i < curNode->usage + 1; i ++ ){
            if(i == curNode->usage || keyVal < curNode->keyArray[i]) {
                //Rightmost position is reached (including when there's no key in the node)
                // or the suitable insertion position is found
                break;
            }
        }

        //Shift all elements after this position
        for(int j = curNode->usage; j > i; j -- ){
            curNode->keyArray[j] = curNode->keyArray[j-1];
            curNode->ridArray[j] = curNode->ridArray[j-1];
        }

        curNode->keyArray[i] = keyVal;
        curNode->ridArray[i] = rid;

        curNode->usage ++;
    }
    else {
        printf("ERROR: insertEntryNonLeafNotFull not implemented for non-int type\n");
    }
    */
}

// -----------------------------------------------------------------------------
// Helper function. Insert an entry to a non-full internal node. 
// Shift elements as needed, but no splitting will happen
// The new pageNo will always be on the right-hand-side of the new key
// -----------------------------------------------------------------------------
const void BTreeIndex::insertEntryNonLeafNotFull(const void* key, const PageId pageNo, void* node) {
    /*
    if(this->attributeType == INTEGER) {
        struct NonLeafNodeInt* curNode = (struct NonLeafNodeInt*)node;

        assert(curNode->usage < this->nodeOccupancy);

        int keyVal = *(int*)key;
        int i = 0;
        for(i = 0; i < curNode->usage + 1; i ++ ){
            if(i == curNode->usage || keyVal < curNode->keyArray[i]) {
                //Rightmost position is reached (including when there's no key in the node)
                // or the suitable insertion position is found
                break;
            }
        }

        //Shift all elements after this position
        for(int j = curNode->usage; j > i; j -- ){
            curNode->keyArray[j] = curNode->keyArray[j-1];
            curNode->pageNoArray[j+1] = curNode->pageNoArray[(j+1) -1];   //shifting the rhs ptr of the key
        }
        curNode->keyArray[i] = keyVal;
        curNode->pageNoArray[i+1] = pageNo;    //insert the ptr to rhs

        curNode->usage ++;
    }
    else {
        printf("ERROR: insertEntryNonLeafNotFull not implemented for non-int type\n");
    }
    */
}

// -----------------------------------------------------------------------------
// BTreeIndex::insertEntry
// -----------------------------------------------------------------------------
const void BTreeIndex::insertEntry(const void *key, const RecordId rid)
{

    PageId upPage = 0;
    void* upKey = NULL;
    if(this->attributeType == INTEGER) {
        PageKeyPair<int>* ret= (PageKeyPair<int>*)this->insertEntry1(key, rid, this->rootPageNum, 0);
        upPage = ret->pageNo;
        upKey = (void*)&ret->key;
    }
    else if(this->attributeType == DOUBLE) {
        PageKeyPair<double>* ret = (PageKeyPair<double>*)this->insertEntry1(key, rid, this->rootPageNum, 0);
        upPage = ret->pageNo;
        upKey = (void*)&ret->key;
    }
    else {
        PageKeyPair<char*>* ret = (PageKeyPair<char*>*)this->insertEntry1(key, rid, this->rootPageNum, 0);
        upPage = ret->pageNo;
        upKey = (void*)&ret->key;
    }
    printf("%d %x\n", upPage, upKey);

    /*
    //Create new root
    if(ret.pageNo != 0) {
        PageId rootPageNo;
        Page* rootPage;
        this->bufMgr->allocPage(this->file, rootPageNo, rootPage);
        struct NonLeafNodeInt* rootNode = (struct NonLeafNodeInt*)rootPage;

        rootNode->pageNoArray[0] = this->rootPageNum;
        this->rootPageNum = rootPageNo;

        insertEntryNonLeafNotFull((void*)&ret.key, ret.pageNo, (void*)rootNode);

        this->bufMgr->unPinPage(this->file, rootPageNo, true);

        this->height ++;
    }
    */
}


const void* BTreeIndex::insertEntry1(const void *key, const RecordId rid, PageId curPageNo, int level) 
{
    /*

    Page* curPage = NULL;
    this->bufMgr->readPage(this->file, curPageNo, curPage);

    int keyVal = *(int*)key;

    PageKeyPair<int> ret;
    ret.set(0, 0);

    //Find the correct position
    //Call itself to recursively insert
    
    if(level == this->height){
        //Base case: Reached leaf
        struct LeafNodeInt* node = (struct LeafNodeInt*)curPage;

        insertEntryLeafNotFull(key, rid, (void*)node);

        if(node->usage == this->leafOccupancy) {
            PageId newPageNo;
            Page* newPage;
            this->bufMgr->allocPage(this->file, newPageNo, newPage);
            struct LeafNodeInt* newNode = (struct LeafNodeInt*)newPage;

            //redistribute
            int cnt = 0;
            for(int i = this->leafOccupancy/2; i < this->leafOccupancy; i ++) {
                //newNode is on the rhs, curNode is on the lhs
                newNode->keyArray[cnt] = node->keyArray[i];
                newNode->ridArray[cnt] = node->ridArray[i];
                cnt ++;
            }

            //set usage
            newNode->usage = cnt;
            node->usage = this->leafOccupancy - cnt;

            //set sib pointers. note: order is important
            newNode->rightSibPageNo = node->rightSibPageNo;
            node->rightSibPageNo = newPageNo;

            //copy up
            ret.set(newPageNo, newNode->keyArray[0]);

            //Jobs with the new node is done. Release the new node
            this->bufMgr->unPinPage(this->file, newPageNo, true);
        }
    }
    else {
        struct NonLeafNodeInt* node = (struct NonLeafNodeInt*)curPage;

        int i;
        for(i = 0; i < node->usage + 1; i ++ ){
            if(i == node->usage || keyVal < node->keyArray[i]) {
                //Rightmost position is reached (including when there's no key in the node)
                // or the suitable insertion position is found
                break;
            }
        }

        PageKeyPair<int> pushUp = this->insertEntry1(key, rid, node->pageNoArray[i], level + 1);
        if(pushUp.pageNo != 0) {

            insertEntryNonLeafNotFull((void*)&pushUp.key, pushUp.pageNo, (void*)node);

            if(node->usage == this->nodeOccupancy) {
                PageId newPageNo;
                Page* newPage;
                this->bufMgr->allocPage(this->file, newPageNo, newPage);
                struct NonLeafNodeInt* newNode = (struct NonLeafNodeInt*)newPage;

                //push up
                ret.set(newPageNo, node->keyArray[this->nodeOccupancy/2]);

                //redistribute
                int cnt = 0;
                for(int i = this->nodeOccupancy/2+1; i < this->nodeOccupancy; i ++) {
                    newNode->keyArray[cnt] = node->keyArray[i];
                    newNode->pageNoArray[cnt] = node->pageNoArray[i];
                    cnt ++;
                }
                newNode->pageNoArray[cnt] = node->pageNoArray[this->nodeOccupancy];

                //set usage
                newNode->usage = cnt;
                node->usage = this->nodeOccupancy - cnt - 1;

                //Jobs with the new node is done. Release the new node
                this->bufMgr->unPinPage(this->file, newPageNo, true);
            }
        }
    }
    
    //Get the return value: a <key, pageno> pair to be inserted into itself

    //Insert the pair, and push up if necessary

    this->bufMgr->unPinPage(this->file, curPageNo, true);
    return ret;
    */
}


// -----------------------------------------------------------------------------
// BTreeIndex::startScan
// -----------------------------------------------------------------------------

const void BTreeIndex::startScan(const void* lowValParm,
				   const Operator lowOpParm,
				   const void* highValParm,
				   const Operator highOpParm)
{


    if((lowOpParm != GT && lowOpParm != GTE) || (highOpParm != LT && highOpParm != LTE)) {
        throw new BadOpcodesException();
    }

	this->scanExecuting = true;

	this->lowOp = lowOpParm;
	this->highOp = highOpParm;

    this->scannedPageNum = std::vector<PageId>();

    if(this->attributeType == INTEGER) {

        /*

        int lowKeyVal = *(int*)lowValParm;
        int highKeyVal = *(int*)highValParm;
        if(lowKeyVal > highKeyVal) {
            throw new BadScanrangeException();
        }

        this->lowValInt = lowKeyVal;
        this->highValInt = highKeyVal;

        int level = 0;
        PageId curPageNo = this->rootPageNum;
        Page* curPage = NULL;
        while(level++ < this->height) {
            this->bufMgr->readPage(this->file, curPageNo, curPage);

            struct NonLeafNodeInt* curNode = (struct NonLeafNodeInt*)curPage;

            //Note: we must scan from rhs until some key less than the lowVal. 
            int i = curNode->usage - 1;
            for(i = curNode->usage - 1; i >= 0; i -- ){
                if(curNode->keyArray[i] <= lowKeyVal) {
                    break;
                }
            }


            PageId tmpPageNo = curNode->pageNoArray[i + 1]; //Use the page ptr to the found key's right

            printf("searching internal node... next page: %d\n", tmpPageNo);

            this->bufMgr->unPinPage(this->file, curPageNo, false);

            curPageNo = tmpPageNo;
        }

        printf("leaf page no: %d\n", curPageNo);

    
        PageId leafPageNo = curPageNo;
        Page* leafPage = NULL;
        this->bufMgr->readPage(this->file, leafPageNo, leafPage);

        struct LeafNodeInt* leafNode = (struct LeafNodeInt*)leafPage;

        for(int i = 0; i < leafNode->usage; i ++ ){
            if((lowOpParm == GT && lowKeyVal < leafNode->keyArray[i]) || (lowOpParm == GTE && lowKeyVal <= leafNode->keyArray[i])) {
                this->nextEntry = i;
                printf("starting scan at %d %d %d\n", curPageNo, i, leafNode->keyArray[i]);
                break;
            }
        }

        this->currentPageNum = leafPageNo;
        this->scannedPageNum.push_back(leafPageNo);
        this->currentPageData = leafPage;
        */

    }
    else if(this->attributeType == DOUBLE){
        /*
        this->nextEntry;
        this->currentPageNum;
        this->currentPageData;
        this->lowValInt;
        this->lowValDouble;
        this->lowValString;
        this->highValInt;
        this->highValDouble;
        this->highValString;
        */
    
    }
    else {
    }
}

// -----------------------------------------------------------------------------
// BTreeIndex::scanNext
// -----------------------------------------------------------------------------

const void BTreeIndex::scanNext(RecordId& outRid) 
{
    /*
    if(this->attributeType == INTEGER) {
        struct LeafNodeInt* curNode = (struct LeafNodeInt*)this->currentPageData;
        int nextKeyVal = curNode->keyArray[this->nextEntry];

        if(this->currentPageNum == 0 || this->nextEntry == curNode->usage) {
            throw IndexScanCompletedException();
        }
    

        if((this->highOp == LT && this->highValInt <= nextKeyVal) || (this->highOp == LTE && this->highValInt < nextKeyVal)) {
            throw IndexScanCompletedException();
        }

        outRid = curNode->ridArray[this->nextEntry ++ ];

        if(this->nextEntry == curNode->usage) {
            this->currentPageNum = curNode->rightSibPageNo;
            if(this->currentPageNum != 0) {
                this->bufMgr->readPage(this->file, this->currentPageNum, this->currentPageData);
                this->nextEntry = 0;
                this->scannedPageNum.push_back(this->currentPageNum);
            }
        }
    }
    else {
    
    }

    */
}

// -----------------------------------------------------------------------------
// BTreeIndex::endScan
// -----------------------------------------------------------------------------
//
const void BTreeIndex::endScan() 
{
    for(size_t i = 0; i < this->scannedPageNum.size(); i ++) {
        this->bufMgr->unPinPage(this->file, this->scannedPageNum[i], false);
    }

	this->scanExecuting = true;
}

/*
 *

// -----------------------------------------------------------------------------
// BTreeIndex::printMeta
// -----------------------------------------------------------------------------

const void BTreeIndex::printMeta() 
{
    this->bufMgr->printSelfNonNull();
    const PageId metaInfoPageNo = 1;
    Page* metaInfoPage = NULL;
    this->bufMgr->readPage(this->file, metaInfoPageNo, metaInfoPage);
    struct IndexMetaInfo* indexMetaInfo = (struct IndexMetaInfo*)(metaInfoPage);

    std::cout<<"\n========== Index Meta Info ==========\n";

    std::cout<<"RootPageNo: "<<indexMetaInfo->rootPageNo<<std::endl;
    std::cout<<"Height: "<<indexMetaInfo->height<<std::endl;
    std::cout<<"AttrByteOffset: "<<indexMetaInfo->attrByteOffset<<std::endl;
    std::cout<<"RelationName: "<<indexMetaInfo->relationName<<std::endl;
    std::cout<<"AttrType: "<<indexMetaInfo->attrType<<std::endl;

    this->bufMgr->unPinPage(this->file, metaInfoPageNo, false);

    std::cout<<"=====================================\n\n";
}

// -----------------------------------------------------------------------------
// BTreeIndex::printNode
// -----------------------------------------------------------------------------
//
const void BTreeIndex::printNode(NonLeafNodeInt* node, PageId pageNo)
{
    std::cout<<"\n========== Node "<<pageNo<<" ==========\n";
    std::cout<<"Occupancy: "<<INTARRAYNONLEAFSIZE<<std::endl;
    std::cout<<"Usage: "<<node->usage<<std::endl;
    std::cout<<"Content: "<<std::endl;
    for(int i = 0; i < node->usage; i ++) {
        std::cout<<" ["<<node->pageNoArray[i]<<"] ";
        std::cout<<node->keyArray[i];
    }
    std::cout<<" ["<<node->pageNoArray[node->usage]<<"]";
    std::cout<<std::endl;
    std::cout<<"===============================\n\n";
}


const void BTreeIndex::printNode(LeafNodeInt* node, PageId pageNo)
{
    std::cout<<"\n========== Node "<<pageNo<<" ==========\n";
    std::cout<<"Occupancy: "<<INTARRAYLEAFSIZE<<std::endl;
    std::cout<<"Usage: "<<node->usage<<std::endl;
    std::cout<<"SibPage: "<<node->rightSibPageNo<<std::endl;

    std::cout<<"Keys: "<<std::endl;
    for(int i = 0; i < node->usage; i ++) {
        std::cout<<node->keyArray[i]<<" ";
    }
    std::cout<<std::endl;
    std::cout<<"===============================\n\n";
}

// -----------------------------------------------------------------------------
// BTreeIndex::dumpAllLevels
// -----------------------------------------------------------------------------

const void BTreeIndex::dumpAllLevels()  
{
    for(int i = 0; i <= this->height; i ++) {
        printf("Dumping Level %d\n", i);
        if(i != this->height)
            dumpLevel(i);
        else
            dumpLeaf();
    }
}

// -----------------------------------------------------------------------------
// BTreeIndex::dumpLevel
// -----------------------------------------------------------------------------

const void BTreeIndex::dumpLevel(int dumpLevel)  
{
    dumpLevel1(this->rootPageNum, 0, dumpLevel);
}


const void BTreeIndex::dumpLevel1(PageId curPageNo, int curLevel, int dumpLevel) 
{
    if(curLevel > dumpLevel) {
        return;
    }
    Page* curPage = NULL;

    if(curPageNo != 0) {
        this->bufMgr->readPage(this->file, curPageNo, curPage);
        struct NonLeafNodeInt* curNode = (struct NonLeafNodeInt*)curPage;
        if(curLevel == dumpLevel) {
            printf("%d: ", curPageNo);
            for(int i = 0; i < curNode->usage; i ++) {
                printf("[%d] %d ", curNode->pageNoArray[i], curNode->keyArray[i]);
            }
            printf("[%d]\n", curNode->pageNoArray[curNode->usage]);
        }
        else {
            for(int i = 0; i < curNode->usage + 1; i ++) {
                dumpLevel1(curNode->pageNoArray[i], curLevel + 1, dumpLevel);
            }
        }
        this->bufMgr->unPinPage(this->file, curPageNo, false);
    }
}

// -----------------------------------------------------------------------------
// BTreeIndex::dumpLeaf
// -----------------------------------------------------------------------------

const void BTreeIndex::dumpLeaf() 
{
    PageId curPageNo = this->rootPageNum;
    Page* curPage = NULL;
    for(int i = 0; i < this->height; i ++) {
        this->bufMgr->readPage(this->file, curPageNo, curPage);
        struct NonLeafNodeInt* curNode = (struct NonLeafNodeInt*)curPage;
        PageId tmp = curPageNo;
        curPageNo = curNode->pageNoArray[0];
        this->bufMgr->unPinPage(this->file, tmp, false);
    }

    while(curPageNo != 0) {
        this->bufMgr->readPage(this->file, curPageNo, curPage);
        struct LeafNodeInt* curNode = (struct LeafNodeInt*)curPage;
        printf("%d: ", curPageNo);
        for(int i = 0; i < curNode->usage; i ++) {
            printf("%d ", curNode->keyArray[i]);
        }
        printf("\n");
        PageId tmp = curPageNo;
        curPageNo = curNode->rightSibPageNo;
        this->bufMgr->unPinPage(this->file, tmp, false);
    }
}
*/


}
