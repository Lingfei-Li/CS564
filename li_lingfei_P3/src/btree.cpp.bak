/**
 * @author See Contributors.txt for code contributors and overview of BadgerDB.
 *
 * @section LICENSE
 * Copyright (c) 2012 Database Group, Computer Sciences Department, University of Wisconsin-Madison.
 */

#include "btree.h"
#include "filescan.h"
#include "exceptions/bad_index_info_exception.h"
#include "exceptions/bad_opcodes_exception.h"
#include "exceptions/bad_scanrange_exception.h"
#include "exceptions/no_such_key_found_exception.h"
#include "exceptions/scan_not_initialized_exception.h"
#include "exceptions/index_scan_completed_exception.h"
#include "exceptions/file_not_found_exception.h"
#include "exceptions/invalid_page_exception.h"
#include "exceptions/end_of_file_exception.h"

#include <string>
#include <sstream>
#include <vector>


//#define DEBUG

namespace badgerdb
{

// -----------------------------------------------------------------------------
// BTreeIndex::BTreeIndex -- Constructor
// -----------------------------------------------------------------------------
BTreeIndex::BTreeIndex(const std::string & relationName,
		std::string & outIndexName,
		BufMgr *bufMgrIn,
		const int attrByteOffset,
		const Datatype attrType)
{

    printf("BTreeIndex: constructor invoked\n");

    //Init buffer manager, attr type, attr offset
    this->bufMgr = bufMgrIn;
    this->attributeType = attrType;
    this->attrByteOffset = attrByteOffset;

    //Determine index filename
    std::ostringstream idxStr;
    idxStr<<relationName<<"."<<attrByteOffset;
    std::string indexName = idxStr.str();

    outIndexName = indexName;

    //Init non-leaf and leaf node occupancy
    if(attrType == INTEGER) {
        this->leafOccupancy = INTARRAYLEAFSIZE;
        this->nodeOccupancy = INTARRAYNONLEAFSIZE;

    } else if(attrType == DOUBLE) {
        this->leafOccupancy = DOUBLEARRAYLEAFSIZE;
        this->nodeOccupancy = DOUBLEARRAYNONLEAFSIZE;

    } else if(attrType == STRING) {
        this->leafOccupancy = STRINGARRAYLEAFSIZE;
        this->nodeOccupancy = STRINGARRAYNONLEAFSIZE;
    }

    printf("Node and leaf occupancy: %d, %d\n", this->nodeOccupancy, this->leafOccupancy);

    //Open or create the index file
    if(File::exists(indexName)) {
        printf("BTreeIndex: constructor: existing file read\n");
        this->file = new BlobFile(indexName, false);

        //Read info from meta info page
        const PageId metaInfoPageNo = 1;
        Page* metaInfoPage = NULL;
        this->bufMgr->readPage(this->file, metaInfoPageNo, metaInfoPage);
        struct IndexMetaInfo* indexMetaInfo = (struct IndexMetaInfo*)(metaInfoPage);
        this->rootPageNum = indexMetaInfo->rootPageNo;
        this->height = indexMetaInfo->height;

        //Release meta info page
        this->bufMgr->unPinPage(this->file, metaInfoPageNo, false);
    }
    else {
        printf("BTreeIndex: constructor: new index file created\n");
        this->file = new BlobFile(indexName, true);

        PageId metaInfoPageNo = 0;
        Page* metaInfoPage = NULL;

        //Allocate meta info page for the index page
        this->bufMgr->allocPage(this->file, metaInfoPageNo, metaInfoPage);
        assert(metaInfoPageNo == 1);

        this->headerPageNum = metaInfoPageNo;
        struct IndexMetaInfo* indexMetaInfo = (struct IndexMetaInfo*)metaInfoPage;
        strncpy(indexMetaInfo->relationName, indexName.c_str(), indexName.length());
        indexMetaInfo->attrByteOffset = attrByteOffset;
        indexMetaInfo->attrType = attrType;

        //Allocate root page for the index file
        PageId rootPageNo = 0;
        Page* rootPage = NULL;
        this->bufMgr->allocPage(this->file, rootPageNo, rootPage);
        this->rootPageNum = indexMetaInfo->rootPageNo = rootPageNo;
        this->height = indexMetaInfo->height = 0;

        //Build the root node as leaf to init the tree structure
        if(attrType == INTEGER) {
            //cast the root as a new leaf node
            struct LeafNodeInt* rootNode = (struct LeafNodeInt*)rootPage;

            //Init the new node
            for(int i = 0; i < this->leafOccupancy; i ++ ){
                rootNode->keyArray[i] = 0;
            }
            rootNode->leftSibPageNo = 0;
            rootNode->rightSibPageNo = 0;
            rootNode->usage = 0;

        } else {
            printf("Btree constructor for double and string not implemented yet\n");
            return;
        }

        //Release meta info page
        this->bufMgr->unPinPage(this->file, metaInfoPageNo, true);
        //Release root node
        this->bufMgr->unPinPage(this->file, this->rootPageNum, true);
    }

    printMeta();

    printf("BTreeIndex: constructor finished\n");
}


// -----------------------------------------------------------------------------
// BTreeIndex::~BTreeIndex -- destructor
// -----------------------------------------------------------------------------

BTreeIndex::~BTreeIndex()
{ }


// -----------------------------------------------------------------------------
// Helper function. Insert an entry to a non-full leaf node. 
// Shift elements as needed, but no splitting will happen
// -----------------------------------------------------------------------------
const void BTreeIndex::insertEntryLeafNotFull(const void* key, const RecordId rid, void* node) {
    if(this->attributeType == INTEGER) {
        struct LeafNodeInt* curNode = (struct LeafNodeInt*)node;

        assert(curNode->usage < this->nodeOccupancy);

        int keyVal = *(int*)key;
        int i = 0;
        for(i = 0; i < curNode->usage + 1; i ++ ){
            if(i == curNode->usage || keyVal < curNode->keyArray[i]) {
                //Rightmost position is reached (including when there's no key in the node)
                // or the suitable insertion position is found
                break;
            }
        }

        //Shift all elements after this position
        for(int j = curNode->usage; j > i; j -- ){
            curNode->keyArray[j] = curNode->keyArray[j-1];
            curNode->ridArray[j] = curNode->ridArray[j-1];
        }

        curNode->keyArray[i] = keyVal;
        curNode->ridArray[i] = rid;

        curNode->usage ++;
    }
    else {
        printf("ERROR: insertEntryNonLeafNotFull not implemented for non-int type\n");
    }
}

// -----------------------------------------------------------------------------
// Helper function. Insert an entry to a non-full internal node. 
// Shift elements as needed, but no splitting will happen
// The new pageNo will always be on the right-hand-side of the new key
// -----------------------------------------------------------------------------
const void BTreeIndex::insertEntryNonLeafNotFull(const void* key, const PageId pageNo, void* node) {
    if(this->attributeType == INTEGER) {
        struct NonLeafNodeInt* curNode = (struct NonLeafNodeInt*)node;

        assert(curNode->usage < this->nodeOccupancy);

        int keyVal = *(int*)key;
        int i = 0;
        for(i = 0; i < curNode->usage + 1; i ++ ){
            if(i == curNode->usage || keyVal < curNode->keyArray[i]) {
                //Rightmost position is reached (including when there's no key in the node)
                // or the suitable insertion position is found
                break;
            }
        }

        //Shift all elements after this position
        for(int j = curNode->usage; j > i; j -- ){
            curNode->keyArray[j] = curNode->keyArray[j-1];
            curNode->pageNoArray[j+1] = curNode->pageNoArray[(j+1) -1];   //shifting the rhs ptr of the key
        }
        curNode->keyArray[i] = keyVal;
        curNode->pageNoArray[i+1] = pageNo;    //insert the ptr to rhs

        curNode->usage ++;
    }
    else {
        printf("ERROR: insertEntryNonLeafNotFull not implemented for non-int type\n");
    }
}

// -----------------------------------------------------------------------------
// BTreeIndex::insertEntry
// -----------------------------------------------------------------------------
const void BTreeIndex::insertEntry(const void *key, const RecordId rid)
{

    PageKeyPair<int> ret = this->insertEntry1(key, rid, this->rootPageNum, 0);

    //Create new root
    if(ret.pageNo != 0) {
        PageId rootPageNo;
        Page* rootPage;
        this->bufMgr->allocPage(this->file, rootPageNo, rootPage);
        struct NonLeafNodeInt* rootNode = (struct NonLeafNodeInt*)rootPage;

        rootNode->pageNoArray[0] = this->rootPageNum;
        this->rootPageNum = rootPageNo;

        insertEntryNonLeafNotFull((void*)&ret.key, ret.pageNo, (void*)rootNode);

        this->bufMgr->unPinPage(this->file, rootPageNo, true);

        this->height ++;
    }
}

const PageKeyPair<int> BTreeIndex::insertEntry1(const void *key, const RecordId rid, PageId curPageNo, int level) 
{

    Page* curPage = NULL;
    this->bufMgr->readPage(this->file, curPageNo, curPage);

    int keyVal = *(int*)key;

    PageKeyPair<int> ret;
    ret.set(0, 0);

    //Find the correct position
    //Call itself to recursively insert
    
    if(level == this->height){
        //Base case: Reached leaf
        struct LeafNodeInt* node = (struct LeafNodeInt*)curPage;

        insertEntryLeafNotFull(key, rid, (void*)node);

        if(node->usage == this->leafOccupancy) {
            PageId newPageNo;
            Page* newPage;
            this->bufMgr->allocPage(this->file, newPageNo, newPage);
            struct LeafNodeInt* newNode = (struct LeafNodeInt*)newPage;

            //redistribute
            int cnt = 0;
            for(int i = this->leafOccupancy/2; i < this->leafOccupancy; i ++) {
                //newNode is on the rhs, curNode is on the lhs
                newNode->keyArray[cnt] = node->keyArray[i];
                newNode->ridArray[cnt] = node->ridArray[i];
                cnt ++;
            }

            //set usage
            newNode->usage = cnt;
            node->usage = this->leafOccupancy - cnt;

            //set sib pointers. note: order is important
            newNode->rightSibPageNo = node->rightSibPageNo;
            newNode->leftSibPageNo = curPageNo;
            node->rightSibPageNo = newPageNo;

            //Update right node's left sib
            Page* rightSibPage;
            if(newNode->rightSibPageNo != 0) {
                this->bufMgr->readPage(this->file, newNode->rightSibPageNo, rightSibPage);
                LeafNodeInt* rightSibNode = (LeafNodeInt*)rightSibPage;
                rightSibNode->leftSibPageNo = newPageNo;
                this->bufMgr->unPinPage(this->file, newNode->rightSibPageNo, true);
            }


            //copy up
            ret.set(newPageNo, newNode->keyArray[0]);

            //Jobs with the new node is done. Release the new node
            this->bufMgr->unPinPage(this->file, newPageNo, true);
        }
    }
    else {
        struct NonLeafNodeInt* node = (struct NonLeafNodeInt*)curPage;

        int i;
        for(i = 0; i < node->usage + 1; i ++ ){
            if(i == node->usage || keyVal < node->keyArray[i]) {
                //Rightmost position is reached (including when there's no key in the node)
                // or the suitable insertion position is found
                break;
            }
        }

        PageKeyPair<int> pushUp = this->insertEntry1(key, rid, node->pageNoArray[i], level + 1);
        if(pushUp.pageNo != 0) {

            insertEntryNonLeafNotFull((void*)&pushUp.key, pushUp.pageNo, (void*)node);

            if(node->usage == this->nodeOccupancy) {
                PageId newPageNo;
                Page* newPage;
                this->bufMgr->allocPage(this->file, newPageNo, newPage);
                struct NonLeafNodeInt* newNode = (struct NonLeafNodeInt*)newPage;

                //push up
                ret.set(newPageNo, node->keyArray[this->nodeOccupancy/2]);

                //redistribute
                int cnt = 0;
                for(int i = this->nodeOccupancy/2+1; i < this->nodeOccupancy; i ++) {
                    newNode->keyArray[cnt] = node->keyArray[i];
                    newNode->pageNoArray[cnt] = node->pageNoArray[i];
                    cnt ++;
                }
                newNode->pageNoArray[cnt] = node->pageNoArray[this->nodeOccupancy];

                //set usage
                newNode->usage = cnt;
                node->usage = this->nodeOccupancy - cnt - 1;

                //Jobs with the new node is done. Release the new node
                this->bufMgr->unPinPage(this->file, newPageNo, true);
            }
        }
    }
    
    //Get the return value: a <key, pageno> pair to be inserted into itself

    //Insert the pair, and push up if necessary

    this->bufMgr->unPinPage(this->file, curPageNo, true);
    return ret;
}


// -----------------------------------------------------------------------------
// BTreeIndex::startScan
// -----------------------------------------------------------------------------

const void BTreeIndex::startScan(const void* lowValParm,
				   const Operator lowOpParm,
				   const void* highValParm,
				   const Operator highOpParm)
{


    if((lowOpParm != GT && lowOpParm != GTE) || (highOpParm != LT && highOpParm != LTE)) {
        throw BadOpcodesException();
    }

	this->scanExecuting = true;

	this->lowOp = lowOpParm;
	this->highOp = highOpParm;

    this->scannedPageNum = std::vector<PageId>();

    if(this->attributeType == INTEGER) {
        int lowKeyVal = *(int*)lowValParm;
        int highKeyVal = *(int*)highValParm;
        if(lowKeyVal > highKeyVal) {
            throw BadScanrangeException();
        }

        this->lowValInt = lowKeyVal;
        this->highValInt = highKeyVal;

        int level = 0;
        PageId curPageNo = this->rootPageNum;
        Page* curPage = NULL;
        while(level++ < this->height) {
            this->bufMgr->readPage(this->file, curPageNo, curPage);

            struct NonLeafNodeInt* curNode = (struct NonLeafNodeInt*)curPage;

            //Note: we must scan from rhs until some key less than the lowVal. 
            int i = curNode->usage - 1;
            for(i = curNode->usage - 1; i >= 0; i -- ){
                if(curNode->keyArray[i] <= lowKeyVal) {
                    break;
                }
            }


            PageId tmpPageNo = curNode->pageNoArray[i + 1]; //Use the page ptr to the found key's right

            printf("searching internal node... next page: %d\n", tmpPageNo);

            this->bufMgr->unPinPage(this->file, curPageNo, false);

            curPageNo = tmpPageNo;
        }

        printf("leaf page no: %d\n", curPageNo);

    
        PageId leafPageNo = curPageNo;
        Page* leafPage = NULL;
        this->bufMgr->readPage(this->file, leafPageNo, leafPage);

        struct LeafNodeInt* leafNode = (struct LeafNodeInt*)leafPage;

        for(int i = 0; i < leafNode->usage; i ++ ){
            if((lowOpParm == GT && lowKeyVal < leafNode->keyArray[i]) || (lowOpParm == GTE && lowKeyVal <= leafNode->keyArray[i])) {
                this->nextEntry = i;
                printf("starting scan at %d %d %d\n", curPageNo, i, leafNode->keyArray[i]);
                break;
            }
        }

        this->currentPageNum = leafPageNo;
        this->scannedPageNum.push_back(leafPageNo);
        this->currentPageData = leafPage;

    }
    else if(this->attributeType == DOUBLE){
        /*
        this->nextEntry;
        this->currentPageNum;
        this->currentPageData;
        this->lowValInt;
        this->lowValDouble;
        this->lowValString;
        this->highValInt;
        this->highValDouble;
        this->highValString;
        */
    
    }
    else {
    }
}

// -----------------------------------------------------------------------------
// BTreeIndex::scanNext
// -----------------------------------------------------------------------------

const void BTreeIndex::scanNext(RecordId& outRid) 
{
    if(this->attributeType == INTEGER) {
        struct LeafNodeInt* curNode = (struct LeafNodeInt*)this->currentPageData;
        int nextKeyVal = curNode->keyArray[this->nextEntry];

        if(this->currentPageNum == 0 || this->nextEntry == curNode->usage) {
            throw IndexScanCompletedException();
        }
    

        if((this->highOp == LT && this->highValInt <= nextKeyVal) || (this->highOp == LTE && this->highValInt < nextKeyVal)) {
            throw IndexScanCompletedException();
        }

        outRid = curNode->ridArray[this->nextEntry ++ ];

        if(this->nextEntry == curNode->usage) {
            this->currentPageNum = curNode->rightSibPageNo;
            if(this->currentPageNum != 0) {
                this->bufMgr->readPage(this->file, this->currentPageNum, this->currentPageData);
                this->nextEntry = 0;
                this->scannedPageNum.push_back(this->currentPageNum);
            }
        }
    }
    else {
    
    }

}

// -----------------------------------------------------------------------------
// BTreeIndex::endScan
// -----------------------------------------------------------------------------
//
const void BTreeIndex::endScan() 
{
    for(size_t i = 0; i < this->scannedPageNum.size(); i ++) {
        this->bufMgr->unPinPage(this->file, this->scannedPageNum[i], false);
    }

	this->scanExecuting = true;
}


// -----------------------------------------------------------------------------
// BTreeIndex::printNode
// -----------------------------------------------------------------------------
//
const void BTreeIndex::printNode(NonLeafNodeInt* node, PageId pageNo)
{
    std::cout<<"\n========== Node "<<pageNo<<" ==========\n";
    std::cout<<"Occupancy: "<<INTARRAYNONLEAFSIZE<<std::endl;
    std::cout<<"Usage: "<<node->usage<<std::endl;
    std::cout<<"Content: "<<std::endl;
    for(int i = 0; i < node->usage; i ++) {
        std::cout<<" ["<<node->pageNoArray[i]<<"] ";
        std::cout<<node->keyArray[i];
    }
    std::cout<<" ["<<node->pageNoArray[node->usage]<<"]";
    std::cout<<std::endl;
    std::cout<<"===============================\n\n";
}


const void BTreeIndex::printNode(LeafNodeInt* node, PageId pageNo)
{
    std::cout<<"\n========== Node "<<pageNo<<" ==========\n";
    std::cout<<"Occupancy: "<<INTARRAYLEAFSIZE<<std::endl;
    std::cout<<"Usage: "<<node->usage<<std::endl;
    std::cout<<"SibPage: "<<node->rightSibPageNo<<std::endl;

    std::cout<<"Keys: "<<std::endl;
    for(int i = 0; i < node->usage; i ++) {
        std::cout<<node->keyArray[i]<<" ";
    }
    std::cout<<std::endl;
    std::cout<<"===============================\n\n";
}

// -----------------------------------------------------------------------------
// BTreeIndex::printMeta
// -----------------------------------------------------------------------------

const void BTreeIndex::printMeta() 
{
    this->bufMgr->printSelfNonNull();
    const PageId metaInfoPageNo = 1;
    Page* metaInfoPage = NULL;
    this->bufMgr->readPage(this->file, metaInfoPageNo, metaInfoPage);
    struct IndexMetaInfo* indexMetaInfo = (struct IndexMetaInfo*)(metaInfoPage);

    std::cout<<"\n========== Index Meta Info ==========\n";

    std::cout<<"RootPageNo: "<<indexMetaInfo->rootPageNo<<std::endl;
    std::cout<<"Height: "<<indexMetaInfo->height<<std::endl;
    std::cout<<"AttrByteOffset: "<<indexMetaInfo->attrByteOffset<<std::endl;
    std::cout<<"RelationName: "<<indexMetaInfo->relationName<<std::endl;
    std::cout<<"AttrType: "<<indexMetaInfo->attrType<<std::endl;

    this->bufMgr->unPinPage(this->file, metaInfoPageNo, false);

    std::cout<<"=====================================\n\n";
}

// -----------------------------------------------------------------------------
// BTreeIndex::dumpAllLevels
// -----------------------------------------------------------------------------

const void BTreeIndex::dumpAllLevels()  
{
    for(int i = 0; i <= this->height; i ++) {
        printf("Dumping Level %d\n", i);
        if(i != this->height)
            dumpLevel(i);
        else
            dumpLeaf();
    }
}

// -----------------------------------------------------------------------------
// BTreeIndex::dumpLevel
// -----------------------------------------------------------------------------

const void BTreeIndex::dumpLevel(int dumpLevel)  
{
    dumpLevel1(this->rootPageNum, 0, dumpLevel);
}


const void BTreeIndex::dumpLevel1(PageId curPageNo, int curLevel, int dumpLevel) 
{
    if(curLevel > dumpLevel) {
        return;
    }
    Page* curPage = NULL;

    if(curPageNo != 0) {
        this->bufMgr->readPage(this->file, curPageNo, curPage);
        struct NonLeafNodeInt* curNode = (struct NonLeafNodeInt*)curPage;
        if(curLevel == dumpLevel) {
            printf("%d: ", curPageNo);
            for(int i = 0; i < curNode->usage; i ++) {
                printf("[%d] %d ", curNode->pageNoArray[i], curNode->keyArray[i]);
            }
            printf("[%d]\n", curNode->pageNoArray[curNode->usage]);
        }
        else {
            for(int i = 0; i < curNode->usage + 1; i ++) {
                dumpLevel1(curNode->pageNoArray[i], curLevel + 1, dumpLevel);
            }
        }
        this->bufMgr->unPinPage(this->file, curPageNo, false);
    }
}

// -----------------------------------------------------------------------------
// BTreeIndex::dumpLeaf
// -----------------------------------------------------------------------------

const void BTreeIndex::dumpLeaf() 
{
    PageId curPageNo = this->rootPageNum;
    Page* curPage = NULL;
    for(int i = 0; i < this->height; i ++) {
        this->bufMgr->readPage(this->file, curPageNo, curPage);
        struct NonLeafNodeInt* curNode = (struct NonLeafNodeInt*)curPage;
        PageId tmp = curPageNo;
        curPageNo = curNode->pageNoArray[0];
        this->bufMgr->unPinPage(this->file, tmp, false);
    }

    while(curPageNo != 0) {
        this->bufMgr->readPage(this->file, curPageNo, curPage);
        struct LeafNodeInt* curNode = (struct LeafNodeInt*)curPage;
//        printf("%d<-%d<-%d: ", curNode->leftSibPageNo, curPageNo, curNode->rightSibPageNo);
        printf("%d<-%d: ", curNode->leftSibPageNo, curPageNo);
        for(int i = 0; i < curNode->usage; i ++) {
            printf("%d ", curNode->keyArray[i]);
        }
        printf("\n");
        PageId tmp = curPageNo;
        curPageNo = curNode->rightSibPageNo;
        this->bufMgr->unPinPage(this->file, tmp, false);
    }
}


const bool BTreeIndex::deleteEntryFromLeaf(const void* key, void* node) {
    LeafNodeInt* curNode = (LeafNodeInt*)node;

    int keyVal = *(int*)key;
    int i = 0;
    for(i = 0; i < curNode->usage; i ++ ){
        if(keyVal == curNode->keyArray[i]) {
            break;
        }
    }

    if(i == curNode->usage) {
        //Not found
        return false;
    }

    //Shift all elements after this position
    for(int j = i; j < curNode->usage - 1; j ++){
        curNode->keyArray[j] = curNode->keyArray[j+1];
        curNode->ridArray[j] = curNode->ridArray[j+1];
    }
    curNode->usage --;
    return true;
}

const void BTreeIndex::deleteEntryFromNonLeaf(const int keyIndex, void* node) {
    NonLeafNodeInt* curNode = (NonLeafNodeInt*)node;
    printf("delete form non leaf index: %d\n", keyIndex);

    //Shift all elements after this position
    for(int j = keyIndex; j < curNode->usage - 1; j ++){
        curNode->keyArray[j] = curNode->keyArray[j+1];
        curNode->pageNoArray[j+1] = curNode->pageNoArray[j+1+1];
    }
    curNode->usage --;
}

const void BTreeIndex::deleteEntry(const void *key)
{

    std::vector<PageId> disposePageNo = std::vector<PageId>();
    this->deleteEntry1(key, this->rootPageNum, NULL, -1, 0, disposePageNo);

//    this->bufMgr->flushFile(this->file);
    for(size_t i = 0; i < disposePageNo.size(); i ++) {
        try{
            this->bufMgr->disposePage(this->file, disposePageNo[i]);
        }catch(InvalidPageException e) {

        }
    }




}

const void BTreeIndex::deleteEntry1(const void *key, PageId curPageNo, void* parentNodeGeneric, int keyIndexAtParent, int level, std::vector<PageId>& disposePageNo)
{

    Page* curPage = NULL;
    this->bufMgr->readPage(this->file, curPageNo, curPage);

    int keyVal = *(int*)key;

    //Find the correct position
    //Call itself to recursively insert
    
    if(level == this->height){
        //Base case: Reached leaf
        struct LeafNodeInt* node = (struct LeafNodeInt*)curPage;

        //delete the entry from node
        if(deleteEntryFromLeaf(key, (void*)node) == false) {
            //Key not found. terminate deletion
            return;
        }

        if(node->usage < this->leafOccupancy/2) {
            printf("usage < n/2\n");
            //Note: Redistribute with left sibling except leftmost node
            if(node->leftSibPageNo != 0) {
                Page* sibPage = NULL;
                this->bufMgr->readPage(this->file, node->leftSibPageNo, sibPage);
                LeafNodeInt* sibNode = (LeafNodeInt*)sibPage;
                printf("sib %d usage: %d\n", node->leftSibPageNo, sibNode->usage);
                if(sibNode->usage > this->leafOccupancy/2) {
                    printf("redistribute with left\n");
                    //Redistribute from sibling

                    int redistFromPos = sibNode->usage - 1;
                    int redistKey = sibNode->keyArray[redistFromPos];
                    RecordId redistRid = sibNode->ridArray[redistFromPos];
                    sibNode->usage --;  //decrem usage == delete the entry

                    insertEntryLeafNotFull((void*)&redistKey, redistRid, (void*)node);

                    //Update the key of parent
                    NonLeafNodeInt* parentNode = (NonLeafNodeInt*)parentNodeGeneric;
                    parentNode->keyArray[keyIndexAtParent] = node->keyArray[0];

                    //All Done
                }
                else {
                    printf("merge into left\n");
                    //Merge into sibling
                    for(int i = 0; i < node->usage; i ++) {
                        sibNode->keyArray[sibNode->usage] = node->keyArray[i];
                        sibNode->ridArray[sibNode->usage] = node->ridArray[i];
                        sibNode->usage ++;
                    }

                    //Delete key from parent
                    deleteEntryFromNonLeaf(keyIndexAtParent, (void*)parentNodeGeneric);
                    printf("deletion complete\n");

                    //Set left and right sib pointers
                    sibNode->rightSibPageNo = node->rightSibPageNo;

                    if(node->rightSibPageNo != 0) {
                        Page* rightSibPage = NULL;
                        this->bufMgr->readPage(this->file, node->rightSibPageNo, rightSibPage);
                        LeafNodeInt* rightSibNode = (LeafNodeInt*)rightSibPage;
                        rightSibNode->leftSibPageNo = node->leftSibPageNo;
                        this->bufMgr->unPinPage(this->file, node->rightSibPageNo, true);
                    }

                    //Dispose curPage
                    disposePageNo.push_back(curPageNo);

                    //Return. Parent will handle its own redistribution/merging
                }
                this->bufMgr->unPinPage(this->file, node->leftSibPageNo, true);
            }
            else {
                //Special case: leftmost node must redistribute/merge with right sibling
                
                Page* sibPage = NULL;
                PageId sibPageNo = node->rightSibPageNo;
                this->bufMgr->readPage(this->file, sibPageNo, sibPage);
                LeafNodeInt* sibNode = (LeafNodeInt*)sibPage;
                if(sibNode->usage > this->leafOccupancy/2) {
                    printf("redistribute with right\n");
                    //Redistribute from sibling

                    int redistFromPos = 0;
                    int redistKey = sibNode->keyArray[redistFromPos];
                    RecordId redistRid = sibNode->ridArray[redistFromPos];
                    deleteEntryFromLeaf((void*)&redistKey, (void*)sibNode);

                    node->keyArray[node->usage] = redistKey;
                    node->ridArray[node->usage] = redistRid;
                    node->usage ++;

                    //Update the key of parent
                    //Since curNode is the leftmost, its right sibling must have the same parent
                    //The position of key to be updated is the index of the key of curNode + 1
                    NonLeafNodeInt* parentNode = (NonLeafNodeInt*)parentNodeGeneric;
                    parentNode->keyArray[keyIndexAtParent+1] = sibNode->keyArray[0];

                    //All Done
                }
                else {
                    //sibling merges into curNode
                    printf("right merge into curnode\n");
                    for(int i = 0; i < sibNode->usage; i ++) {
                        node->keyArray[node->usage] = sibNode->keyArray[i];
                        node->ridArray[node->usage] = sibNode->ridArray[i];
                        node->usage ++;
                    }

                    //Delete sibling's key from parent
                    //Note that sibling's key index must be at current key index + 1
                    deleteEntryFromNonLeaf(keyIndexAtParent+1, (void*)parentNodeGeneric);
                    printf("deletion complete\n");

                    //Set left and right sib pointers
                    node->rightSibPageNo = sibNode->rightSibPageNo;

                    Page* rightSibSibPage = NULL;
                    PageId rightSibSibPageNo = sibNode->rightSibPageNo;
                    if(rightSibSibPageNo != 0) {
                        this->bufMgr->readPage(this->file, rightSibSibPageNo, rightSibSibPage);
                        LeafNodeInt* rightSibSibNode = (LeafNodeInt*)rightSibSibPage;
                        rightSibSibNode->leftSibPageNo = curPageNo;
                        this->bufMgr->unPinPage(this->file, rightSibSibPageNo, true);
                    }

                    //Dispose right sibling
                    disposePageNo.push_back(sibPageNo);

                    //Done with curNode. Parent will handle its own redistribution/merging
                } 
                this->bufMgr->unPinPage(this->file, sibPageNo, true);
            }
        }
        else {
            //Leaf usage > occupancy/2. Do nothing
        
        }
    }
    else {
        //Non-Leaf node
        struct NonLeafNodeInt* node = (struct NonLeafNodeInt*)curPage;

        int i;
        for(i = 0; i < node->usage + 1; i ++ ){
            if(i == node->usage || keyVal < node->keyArray[i]) {
                //Rightmost position is reached (including when there's no key in the node)
                // or the suitable insertion position is found
                break;
            }
        }

        //i-1 because the key to be deleted is between keyArray[i-1] and keyArray[i]
        //when deletion propagates, keyArray[i-1] is the one to be deleted (deleted by children)
        deleteEntry1(key, node->pageNoArray[i], node, i-1, level+1, disposePageNo);
        if(parentNodeGeneric != NULL && node->usage < this->nodeOccupancy/2) {
            if(keyIndexAtParent != -1) {
                //Normal case: redistribute/merge with left sibling

                NonLeafNodeInt* parentNode = (NonLeafNodeInt*)parentNodeGeneric;
                PageId sibPageNo = parentNode->pageNoArray[keyIndexAtParent];       //keyIndex is the same as left sibling's pageNoIndex
                Page* sibPage = NULL;
                this->bufMgr->readPage(this->file, sibPageNo, sibPage);
                NonLeafNodeInt* sibNode = (NonLeafNodeInt*)sibPage;

                if(sibNode->usage > this->nodeOccupancy/2) {
                    printf("internal node redistribute...\n");
                    //borrow(and delete) key value from parent
                    //insert the key to first position of curNode
                    //get the last pageNo from sib. insert it to first position

                    PageId insertionPageNo = sibNode->pageNoArray[sibNode->usage];
                    int insertionKey = parentNode->keyArray[keyIndexAtParent];


                    //Shift all elements to right in curNode
                    for(int j = node->usage; j > 0; j -- ){
                        node->keyArray[j] = node->keyArray[j-1];
                        node->pageNoArray[j+1] = node->pageNoArray[(j+1) -1];   //shifting the rhs ptr of the key
                    }
                    node->pageNoArray[1] = node->pageNoArray[0];

                    node->pageNoArray[0] = insertionPageNo;
                    node->keyArray[0] = insertionKey;

                    node->usage ++;


                    //get the last key from sib. update parent with it
                    parentNode->keyArray[keyIndexAtParent] = sibNode->keyArray[sibNode->usage-1];

                    //shink sib page
                    sibNode->usage --;

                    //Return. parent will handle its own process
                }
                else {
                    //merge with sibling

                    //delete key from parent
                    
                    //return. parent will handle its own process
                
                }

                this->bufMgr->unPinPage(this->file, sibPageNo, true);
            }
            else {
                //Special case: leftmost page ptr in the parent node. redistribute/merge with right sibling
            
                bool redistribute = false;
                if(redistribute) {
                    //borrow(and delete) key value from parent

                    //redistribute with sibling
                    //insert all keys from sibling to pageNoArray. insert keys from sibling or parent to keyArray

                    //Return. parent will handle its own process
                
                }
                else {
                    //merge with sibling

                    //delete key from parent
                    
                    //return. parent will handle its own process
                
                }
            }
        }
    }
    this->bufMgr->unPinPage(this->file, curPageNo, true);
}


}
